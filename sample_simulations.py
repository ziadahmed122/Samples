# -*- coding: utf-8 -*-
"""Sample simulations

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G4ZJEFGshk8OakMiPpdsSfU03As1lf_R

#Heat difussion simulation
- **lines function:**
    - Lines from 1 to 17 are setting up the system. The room is 10 by 10 with an initial guess of 20 as temperature. 
    - Lines 18 and 19 are setting up the grill. It is set to be always in the middle of the room with an initial temperature of 100 at the begging of the simulation.
    - Lines from 20 to 27 are setting up the people. The every person position was set frist. Then, they are added to person list to set their temprature to be 15 at the begging of the simulation.
    - Lines from 33 to 36 are setting up the system to update each cell once every iteration from the number of iterations that we set earlier. 
    - Lines from 39 to 98 are divided into two main for loops. The loops are divied mainly to preform an action at step 60 where they will open a window in the corner of the room starting from that step. Every main loop is updating each cell one time throughout each iteration using the four neighboring cells' temperature. This is true for all the cells to expect the ones on the outer bounds. For those, we use the three neighboring cells for the inner ones and only two in the corner ones. Notice that the number of neighboring cells affects the update functions. For exmple, look at lines 48 and 51. There are two other special kinds of cells to be updated. First, humans(denoted in the graph by a black dots) will be updated normally, like the other cells. However, at the end of the iteration, They will be checked whether they are in bounds or not because they can not have a temperature higher than 25 or lower than 15. if they are over such bounds, they will be brought to the nearest bound.The other type of special cell is the grill(denoted in the graph by a white dot) . The grill does not depend on the other cells; instead, it uses that function $(T(t+1)=T(t)-1)$ with a lower bound of zero.  

- **Visulizations:**
- Heat map snips:
  - Those could be found from line 110 to 120. 
  - The idea behind it to capture the temperature of the room throughout time. Every snip is considered to be one step in time, and the heat is represented by color using the heat map key on the right. Notice that the scale changes over time. Therefore, even when the map gets red, it doesn't always mean it is getting hotter, so I chose to keep it as snips and do the other visualization. 
- The time-temperature graph
  - you can find this graph in lines from 130 to 140.
- Notes:
   - The grill function is a great solution to make the grill lose temperature over time. However, it might not be the best solution for realistic simulation. Look at the end of the simulation; you will find that the grill is now a fridge as it is at temperature zero while it should have been similar to other items in the room. Therefore, having a for loop with counter iteration and limits like the humans would have been a better solution.
"""

import numpy as np
from matplotlib import pyplot as plt
# Set maximum iteration
max_iterations = 100
# Set Dimension and delta (should be set by student)
length_x = 10
length_y = 10 
delta = 1
Tguess = 20
# Set colour interpolation and colour map
colorinterpolation = 50
colourMap = plt.cm.jet 
# Set meshgrid
X, Y = np.meshgrid(np.arange(0, length_x), np.arange(0, length_y))
# Set array size and set the interior value with Tguess
T = np.empty((length_x, length_y))
T.fill(Tguess)
#setting up the grill intially 
T[int(length_x/2), int(length_y/2)]=100
#list of the people (adjustable to any number of people)
person_1 = (int(length_x/2)-2, int(length_y/2)+2)
person_2=(int(length_x/2)-2, int(length_y/2)-2)
person_3=(int(length_x/2)+2, int(length_y/2)+2)
person_4=(int(length_x/2)+2, int(length_y/2)-2)
person_list= [person_1,person_2,person_3,person_4] #inserting the people in the simulation 
for i in person_list:
  T[i[0],i[1]]= 15 #giving people an intial temprature of 15
#Printing the intial state of the system 
print("The intial state of the system is:")
print(T) 
temp_mean=[]
# Iteration 

avrage_person_list=[]
for iteration in range(0, max_iterations):
  person_temp=[]
  for i in range(0, length_x, delta):
      for j in range(0, length_y, delta):
        if iteration > 60: #after 60 time steps
          if (i,j) in [(0,0),(0,length_y-1),(length_x-1,length_y-1),(length_x-1,0)]:
            if (i,j) == (0,0):
              T[i, j] = 0.5 * (T[i+1][j]+ T[i][j+1])# update rule is adjusted to account for 2 cells as nighbours instead of 4 
            if (i,j) == (0,length_y-1): 
              T[i, j] = 0 #open the window to make it zero
            if (i,j) == (length_x-1,length_y-1):
              T[i, j] = 0.5 * ( T[i-1][j] + T[i][j-1]) 
            if (i,j) == (length_x-1,0):
              T[i, j] = 0.5 * (T[i-1][j] + T[i][j+1]) 
          else:
            if i == 0:
              T[i, j] = (1/3) * (T[i+1][j] + T[i][j+1] + T[i][j-1])
            elif i== length_x-1:
              T[i, j] = (1/3) * (T[i-1][j] + T[i][j+1] + T[i][j-1])
            elif j == 0:
              T[i, j] = (1/3) * (T[i+1][j] + T[i-1][j] + T[i][j+1])
            elif j== length_y-1:
              T[i, j] = (1/3) * (T[i-1][j] + T[i+1][j] + T[i][j-1])
            elif (i,j) not in person_list and  (i,j) != (int(length_x/2), int(length_y/2)):
              T[i, j] = 0.25 * (T[i+1][j] + T[i-1][j] + T[i][j+1] + T[i][j-1])
            if (i,j) in person_list:
              if T[i, j] < 25 and T[i, j] > 15: #update the humans within range 
                T[i, j] = 0.25 * (T[i+1][j] + T[i-1][j] + T[i][j+1] + T[i][j-1])
                person_temp.append(T[i, j])
              elif T[i, j] >= 25:#not let humans get over 25 degrees
                T[i, j]= 25
                person_temp.append(T[i, j])
              elif T[i, j] < 15: #not let humans go under 15 degrees
                T[i, j] = 15
                person_temp.append(T[i, j])
        else:
            if (i,j) in [(0,0),(0,length_y-1),(length_x-1,length_y-1),(length_x-1,0)]:
              if (i,j) == (0,0):
                T[i, j] = 0.5 * (T[i+1][j]+ T[i][j+1])# update rule is adjusted to account for 2 cells as nighbours instead of 4 
              if (i,j) == (0,length_y-1): 
                T[i, j] = 0.5 * (T[i+1][j] + T[i][j-1]) 
              if (i,j) == (length_x-1,length_y-1):
                T[i, j] = 0.5 * ( T[i-1][j] + T[i][j-1]) 
              if (i,j) == (length_x-1,0):
                T[i, j] = 0.5 * (T[i-1][j] + T[i][j+1] ) 
            else:
              if i == 0:
                T[i, j] = 0.25 * (T[i+1][j] + T[i][j+1] + T[i][j-1])
              elif i== length_x-1:
                T[i, j] = 0.25 * (T[i-1][j] + T[i][j+1] + T[i][j-1])
              elif j == 0:
                T[i, j] = 0.25 * (T[i+1][j] + T[i-1][j] + T[i][j+1])
              elif j== length_y-1:
                T[i, j] = 0.25 * (T[i-1][j] + T[i+1][j] + T[i][j-1])
              elif (i,j) not in person_list and  (i,j) != (int(length_x/2), int(length_y/2)):
                T[i, j] = 0.25 * (T[i+1][j] + T[i-1][j] + T[i][j+1] + T[i][j-1])
        #update rule for humans 
              if (i,j) in person_list:
                if T[i, j] < 25 and T[i, j] > 15: #update the humans within range 
                  T[i, j] = 0.25 * (T[i+1][j] + T[i-1][j] + T[i][j+1] + T[i][j-1])
                elif T[i, j] >= 25:#not let humans get over 25 degrees
                  T[i, j]= 25
                elif T[i, j] < 15: #not let humans go under 15 degrees
                  T[i, j] = 15
                  

    #upate rule for the grill as time goes on it decreases by one 
  if T[int(length_x/2), int(length_y/2)] <= 0: #limit is to not go less than zero 
    T[int(length_x/2), int(length_y/2)]=0
  else:
    T[int(length_x/2), int(length_y/2)]= T[int(length_x/2), int(length_y/2)]-1
                  
  temp_mean.append(T.mean()) #get the mean temprature for everytime step 
  #getting the contour plot for each step 
  print('This is step number ',iteration+1)
  plt.title("Contour of Temperature")
  plt.contourf(X, Y, T,colorinterpolation, cmap=colourMap)
  plt.colorbar()
  first=[]
  second=[]
  for i in person_list:
    first.append(i[0])
    second.append(i[1])
  plt.scatter(first,second,marker='o',color='black') #people are represented by black dots 
  plt.scatter([int(length_x/2)],[int(length_y/2)],marker='p',color='white') # the oven is represented by white dot 
  plt.show()
  for i in person_list:
    person_temp.append(T[i])
  avrage_person_list.append(sum(person_temp)/4)

#the final values of temps 
print("The final state of the system is:")           
print(T)
#animation
#mean temprature of the system over time  
plt.title("mean of Temperature")
plt.plot(temp_mean,label='Avrage room temprature')
plt.xlabel('Time')
plt.ylabel('Mean temprature')
human_tmp=[]
for i in range (0,max_iterations):
  human_tmp.append(15)
plt.plot(human_tmp,label='normal human Temperature')
plt.plot(avrage_person_list,label='avrage human Temperature')
plt.legend()
plt.show()

"""#Elastic pendulum simulation
We need two equations for the elastic pendulum to get the Euler-Lagrange equations of motion: the potential energy and the kinetic energy. 


>The potential energy is affected by the tension of the spring and the height of the pendulum. The potetial energy from the height of the pendulum could be calculated using the equation $m g y$, which is replaced by $-m g l \cos \theta$ as we calculate the height from the length and the cos of the angle between the pendulum and the y-axis. For the tension, we will use the equation $\frac{1}{2} k\left(l-l_{0}\right)^{2}$. Therefore the final potential energy formula is $P = -m g l \cos \theta+\frac{1}{2} k\left(l-l_{0}\right)^{2}$. 


> The kinetic energy could be calculated using $\frac{1}{2} m v^{2}$. Then, we will need to calculate the v in both the x and y-direction using the derivative of the length (l). Therefore the two components will be $\dot{x}=i \sin \theta+l \dot{\theta} \cos \theta$ and $\dot{y}=-i \cos \theta+l \dot{\theta} \sin \theta$. By replacing them in the original formula, we will get $K=\frac{1}{2} m\left(\dot{l}^{2}+l^{2} \dot{\theta}^{2}\right)$.


> Therefore, the Lagrangian equation will be K - P which is $\mathcal{L}=\frac{1}{2} m\left(i^{2}+l^{2} \dot{\theta}^{2}\right)-\frac{1}{2} k\left(l-l_{0}\right)^{2}+m g l \cos \theta$ . 
- Therefore, the Euler-Lagrange relations for (θ) is $2 i \dot{\theta}+l \ddot{\theta}+g \sin \theta=0$. 
- Moreover, the Euler-Lagrange relations for (l) is $m \ddot{l}-m l \dot{\theta}^{2}+k\left(l-l_{0}\right)-m g \cos \theta=0$.


> Therefore, the two equations for ${z}_{1}$ ( in the x axis ) and ${z}_{2}$ ( in the y axis ) 
  $\begin{aligned} \dot{z}_{1} &=-\frac{1}{l}\left[g \sin \theta+2 z_{1} z_{2}\right] \\ \dot{z}_{2} &=\frac{1}{m}\left[m l z_{1}^{2}-k\left(l-l_{0}\right)+m g \cos \theta\right] \end{aligned}$
which are the two equations used in the getting_derivative in lines 16 and 17. 

The figures : 


> The snips of the pendulum and its path:
- It is a snip of the pendulum ( the red line and the red dot ) after one step of time. The line is meant to be the path of the pendlum sinse the begining till this point of time. 


> Length of the rope: 
- it a graoh of the length of the spring over time. 



> To test this algorithm, we should throw the pendulum directly down. It should give us the same result as a spring as it will not have and will not move around the axes.



Seniro: 
> This might help in rope related sports like Bungee jumping. It could help to stimulate the path that the jumper will take so that we will make sure it is vacant and will not have anything that will come in the way of the jumper. The second graph will help us to know the height of the platform that we are jumping from and how the person would stretch the line. Therefore, this simulation will help to be a safety personalized simulation that will ensure that Bungee jumping would be safe.
"""

import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
import matplotlib.animation as animation

#intial conditions for the system
spring_constant= 30 #spring constant 
inital_lenght= 1 # the intial length of the sprig 
g = 9.81 #gravitational constant of the Earth 
mass = 5 #mass
#getting the function of the integration
def getting_derivative(integration, time, inital_lenght, spring_constant, mass):
    angle, x_intial, current_length, y_intial = integration
    intial_length = y_intial
    intial_angle = x_intial
    frist_equation = (-g*np.sin(angle) - 2*x_intial*y_intial) / current_length
    second_equation = (mass*current_length*x_intial**2 - spring_constant*(mass-inital_lenght) + mass*g*np.cos(angle)) / mass
    return intial_angle, frist_equation, intial_length, second_equation
#setting the system
intial_condition = [3*np.pi/4, 0, inital_lenght, 0] #intial conditions for the system 
#filling the time and integration vectors 
run_time= 10 # amount of time that the pendlum will run for 
time_step =  0.01 #time step (as small as possible for better estimates )
time = np.arange(0, run_time + time_step, time_step) 
intial_condition = [3*np.pi/4, 0, inital_lenght, 0] #intial conditions for the system  
# Use odeint to get the the integration 
integration = odeint(getting_derivative, intial_condition, time, args=(inital_lenght, spring_constant, mass))
current_length = integration[:,2]
angle= integration[:,0]
# the position resulted from the two equations 
x = current_length * np.sin(angle)
y = - current_length * np.cos(angle)
#length of the rope
length=[]
#making the slides 
for i in range (1,len(x)):
  plt.plot(x[:i],y[:i])
  plt.plot([0,x[i-1]],[0,y[i-1]])
  length.append(np.sqrt(x[i-1]**2+y[i-1]**2))
  plt.scatter([x[i-1]],[y[i-1]],marker='p',color='red')
  plt.show()
#showing the plot for the length difference 
plt.plot(length)
plt.show()